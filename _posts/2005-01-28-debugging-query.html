---
layout: post
title: "Debugging a Query"
date: 2005-01-28
comments: false
categories:
 - coldfusion
 - debugging
---

<div class='post'>
I had to debug a query the other day and it was agonizing trying to figure out what was going on. It wasn't that the query was complicated - but the problem was subtle - and thus difficult to find. Here it is:<br /><pre name="code" class="coldfusion"><br />&lt;cfquery name="jurisdictionSelect" datasource="#variables.dsn#"&gt;<br />  SELECT    sh.SectionHeaderID,<br />          sh.chapterid,<br />          sh.sectionnumber,<br />          sh.sectionheadingname,<br />          c.chaptercode,<br />          c.chapterid,<br />          c.chaptername,<br />          s.description,<br />          'Normal' as sectionType,<br />          0 as orderBy<br />   FROM    sectionheader sh,<br />          chapter c,<br />          jurisdictiontypegroupmapping j,<br />          s.sectionheader<br />WHERE j.jurisdictiontypegroupid = &lt;cfqueryparam cfsqltype="cf_sql_integer" value="#attributes.jurisdictiontypegroupid#"&gt;<br />    AND sh.jurisdictiontypeid = j.jurisdictiontypeid<br />    AND c.chaptercode = sh.chapterid<br />    AND s.chapterid = c.chaptercode<br />    AND c.chaptercode NOT LIKE 'O%'<br />    AND c.chaptercode NOT LIKE 'T%'<br />  &lt;!--- get the "Other" chapter id values ---&gt;<br />  UNION (<br />  SELECT    sh.SectionHeaderID,<br />          sh.chapterid,<br />          sh.sectionnumber,<br />          sh.sectionheadingname,<br />          'O' as chaptercode,<br />          c.chapterid,<br />          'Other' as chaptername,<br />          'Other' as sectionType,<br />          s.description,<br />          1 as orderBy<br />    FROM    sectionheader sh,<br />          chapter c,<br />          jurisdictiontypegroupmapping j,<br />          s.sectionheader<br />   WHERE    c.chaptercode LIKE 'O%'<br />AND j.jurisdictiontypegroupid = &lt;cfqueryparam cfsqltype="cf_sql_integer" value="#attributes.jurisdictiontypegroupid#"&gt;<br />     AND sh.jurisdictiontypeid = j.jurisdictiontypeid<br />     AND c.chaptercode = sh.chapterid<br />     AND s.chapterid = c.chaptercode<br />  )<br />  &lt;!--- get the "Toxic" chapter id values ---&gt;<br />  UNION (<br />  SELECT    sh.SectionHeaderID,<br />          sh.chapterid,<br />          sh.sectionnumber,<br />          sh.sectionheadingname,<br />          'T' as chaptercode, c.chapterid,<br />          'Toxic' as chaptername,<br />          'Toxic' as sectionType,<br />          s.description,<br />          2 as orderBy<br />    FROM    sectionheader sh,<br />          chapter c,<br />          jurisdictiontypegroupmapping j<br />   WHERE    c.chaptercode LIKE 'T%'<br />AND j.jurisdictiontypegroupid = &lt;cfqueryparam cfsqltype="cf_sql_integer" value="#attributes.jurisdictiontypegroupid#"&gt;<br />     AND sh.jurisdictiontypeid = j.jurisdictiontypeid<br />     AND c.chaptercode = sh.chapterid<br />     AND s.chapterid = c.chaptercode<br />  )<br /><br />  ORDER BY orderby, chaptercode, chaptername, sectionnumber<br />&lt;/cfquery&gt;<br /></pre><br /><br />The end result was I was getting a nasty cartesian product. But the problem just didn't jump out at me. All three tables were joined nicely - so what gives? If your lucky then the problem jumps right out at you. But for me, I wasn't so lucky. I spent a good twenty minutes mucking with this query in PL/SQL Developer before I finally saw the problem.<br /><br />At first glance you might think the problem is related to the fact that the join between "sh" and "c" is c.chaptercode = sh.chapterid and that the join between "s" and "c" is also s.chapterid = c.chaptercode. It's good place to start looking - but the wrong one. The tables were designed along time ago by someone who once worked for the customer and we are just tasked with extending some functionality around the existing tables - so please, don't complain about the database design.<br /><br />Do you see the problem yet? Well it turns out that in each of the three parts of the query sectionheader is defined twice. So the alias 's' and 'sh' are totally redundant and thus things went whacky with an end result of hundreds, maybe thousands more records being returned than necessary. As soon as I removed referencs to the 'sh' version of the table everything came back to normal. Sometimes I hate debugging - but it always feels good to get the problem fixed.<br /><br />Why did it take me so long to figure this one out? Well first I starting checking the jurisdictiontypegroupmapping table out to see if the mappings were poorly defined - and thus giving me back extra data. Then I started focusing on the actual joins making sure each aliased table had a join that logically chained all of the tables together. Then I dropped the two union parts of the query out. Then I started taking the remaining query apart one table at a time, from the bottom up, to see where things went haywire. I honestly never thought to study the "from" part of the clause because it didn't occur to me that someone would alias the same table twice for reason. Next time, perhaps, I check that first!</div>
