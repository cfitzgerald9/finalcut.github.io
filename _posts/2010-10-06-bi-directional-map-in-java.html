---
layout: post
title: "Bi-Directional MAP in Java with Enumerations"
date: 2010-10-06
comments: false
categories:
 - java
 - enumerations
 - enums
---

<div class='post'>
I recently had a problem where I needed something like a HashMap<string,object> but I needed to be able to lookup both the key from the value and the value from the key. &nbsp; There are a couple ways of doing this but my final solution utilized some of the pretty cool features in Java's enumeration (enum) implementation.</string,object><br /><br />Enumerations are basically just lists of things. &nbsp;In most languages you'll have something like:<br /><br /><br /><pre class="java" name="code">enum Boys { JOHN, MARK, TOM, CARL, BILL }<br /></pre><br /><br />In Java you can do basically the same thing OR you can treat your enumeration just like a class and add additional methods and constructors to it. &nbsp;Sounds crazy so I'll show you an example that solves the initial problem I described.<br /><br /><pre class="java" name="code">import java.util.EnumSet;<br />    ...<br />    <br />    public enum ConnectionStatus { <br />        UNSPECIFIED(""), CONNECTED("Y"), DISCONNECTED("N"), SHUTDOWN("S");<br /><br />        private static final Map<String, ConnectionStatus> lookup = new HashMap<String, ConnectionStatus>();<br /><br />        static { <br />            for (ConnectionStatus s : EnumSet.allOf(ConnectionStatus.class)) <br />                lookup.put(s.getCode(), s); <br />        }<br /><br />        private String code;<br /><br />        private ConnectionStatus(String code) { <br />            this.code = code; <br />        }<br /><br />        public String getCode() { <br />            return code; <br />        }<br /><br />        public static ConnectionStatus get(String code) { <br />            return lookup.get(code.toUpperCase().trim()); <br />        }<br /><br />    }<br /></pre><br /><br />So what does all that do?  It's pretty remarkable really.  The initial part<br /><pre class="java" name="code">UNSPECIFIED(""), CONNECTED("Y"), DISCONNECTED("N"), SHUTDOWN("S");<br /></pre>calls the private constructor, passing in a string ("", "Y", "N", and "S"), for the ConnectionStatus enum for each of the items in the list.  The Constructor then sets a private member variable, within the enum, to the "code" string passed in:<br /><pre class=java" name="code">private String code;<br /><br />        private ConnectionStatus(String code) { <br />            this.code = code; <br />        }<br /></pre><br />There is also a private member variable, within the enumeration called "lookup" that stores the relationships between the codes and the enumeration values in a map; the static block of code right after the private lookup variable is declared initializes the map.<br /><pre class="java" name="code">private static final Map<String, ConnectionStatus> lookup = new HashMap<String, ConnectionStatus>();<br /><br />        static { <br />            for (ConnectionStatus s : EnumSet.allOf(ConnectionStatus.class)) <br />                lookup.put(s.getCode(), s); <br />        }<br /></pre><br /><br />Notice that both of those portions are static while the code member variable, and obviously, the constructor are not.  The static stuff is a "class variable" and thus is shared across all instances of the class (or enumeration) and the non-static stuff are instance variables and are unique to each instance of the enumeration (UNSPECIFIED, CONNECTED, DISCONNECTED, and SHUTDOWN).<br /><br />Because each instance of the enum stores it's code we can very easily get the associated code for each enumeration like so:<br /><pre name="code" class="java">String connectionStatusCode = ConnectionStatus.CONNECTED.getCode();<br /></pre><br />Likewise, thanks to our static map we can pass in a code value and get back the corresponding enumeration<br /><pre name="code" class="java">ConnectionStatus connectionStatus = ConnectionStatus.get("S");<br /></pre><br />The get method is static and uses our static lookup map to efficiently find the corresponding enum for the letter provided; you'll notice I clean up the passed in code string so I can search regardless of case or padding; you may not want to do that.<br /><pre name="code" class="java">public static ConnectionStatus get(String code) { <br />            return lookup.get(code.toUpperCase().trim()); <br />        }<br /></pre><br />Java really gives you a lot of power with their enumeration implementation.  If you wanted to you could add other methods and even "sub-enumerations" to the enumeration (though I can't think of a good use case for sub-enums).   Dig into them and you might be amazed at what you can accomplish.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
for (ConnectionStatus s : EnumSet.allOf(ConnectionStatus.class))<br />should be written as<br />for (ConnectionStatus s : ConnectionStatus.values())</div>
</div>
</div>
