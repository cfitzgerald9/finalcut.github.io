---
layout: post
title: "CF: QueryIntersect UDF"
date: 2009-11-05
comments: false
categories:
 - coldfusion
 - query
 - user-defined-function
 - unit-testing
 - udf
---

<div class='post'>
Today I needed a function that would return the intersection of two query objects (think Matrices and Sets).  If you aren't that familiar with intersections basically what this function does is it returns a query object that contains each cell where the two queries were equal.  Thus if you send in two queries with 10 different columns (excpet one of which in both is "firstname") and in both queries, in the 3rd row, the firstname was "richard" but nothing else about the two queries was equal then the return query would have a bunch of empty rows with one column (firstname) - and the firstname value of the third row would be richard.<br /><br />One of these probably already exists out on the web somewhere but I wanted to write it myself and so I did.<br /><br />A couple of caveats - 1. I know the variable naming sucks; I am lazy; so deal with it.  I don't like having to "var" everything and I don't like typing "local" all the time; so I used very short and not very clear names.  That's ok though becuase I also give you a unit test to show you that the function works the way I expect it to.  Anyway, it's a pretty short function that you can easily update if you want it to be more readable.<br /><br /><pre name="code" class="coldfusion"><br /> &lt;cffunction name="QueryIntersect" access="public" output="false" returntype="query"&gt;<br />  &lt;cfargument name="q1" type="query"&gt;<br />  &lt;cfargument name="q2" type="query"&gt;<br /><br />  &lt;cfset var l = structNew() /&gt;<br />  &lt;!--- <br />   grab all the column names that are the same between the two incoming queries<br />  ---&gt;<br />  &lt;cfset l.colNames = "" /&gt;<br />  &lt;cfloop list="#q2.columnList#" index="l.c"&gt;<br />   &lt;cfif ListFindNoCase(q1.columnList,l.c)&gt;<br />    &lt;cfset l.colNames = listAppend(l.colNames, l.c) /&gt;<br />   &lt;/cfif&gt;<br />  &lt;/cfloop&gt;<br />  <br />  &lt;cfset l.q = QueryNew("#l.colNames#") /&gt;<br /><br />  &lt;cfset l.max = q1.recordCount /&gt;<br />  &lt;cfif q2.recordCount LT q1.recordCount&gt;<br />   &lt;cfset l.max = q2.recordCount&gt;<br />  &lt;/cfif&gt;<br /><br />  &lt;cfloop from="1" to="#l.max#" step="1" index="l.s"&gt;<br />   &lt;cfset QueryAddRow(l.q) /&gt;<br />   &lt;cfloop list="#l.colNames#" index="l.i"&gt;<br />    &lt;cfif q1["#l.i#"]["#l.s#"] EQ q2["#l.i#"]["#l.s#"]&gt;<br />     &lt;cfset querySetCell(l.q,l.i,q1["#l.i#"]["#l.s#"]) /&gt;<br />    &lt;/cfif&gt;<br />   &lt;/cfloop&gt;<br />  &lt;/cfloop&gt;<br /><br />  &lt;cfreturn l.q /&gt;<br /><br /> &lt;/cffunction&gt;<br /></pre><br /><br />Here is the unit test<br /><pre name="code" class="coldfusion"><br /> &lt;cffunction name="QueryIntersectTest" access="public" output="false"&gt;<br /><br />  &lt;cfset var q1 = QueryNew("id,name,title") /&gt;<br />  &lt;cfset var q2 = QueryNew("name,email,id") /&gt;<br />  &lt;cfset var q3 = "" /&gt;<br /><br />  &lt;cfscript&gt;<br />   QueryAddRow(q1);<br />   QuerySetCell(q1,"id","1");<br />   QuerySetCell(q1,"name","bill");<br />   QuerySetCell(q1,"title","chief");<br /><br />   QueryAddRow(q1);<br />   QuerySetCell(q1,"id","2");<br />   QuerySetCell(q1,"name","carl");<br />   QuerySetCell(q1,"title","bozo");<br /><br /><br />   QueryAddRow(q2);<br />   QuerySetCell(q2,"id","1");<br />   QuerySetCell(q2,"name","tom");<br />   QuerySetCell(q2,"email","tom@bob.com");<br /><br />   QueryAddRow(q2);<br />   QuerySetCell(q2,"id","4");<br />   QuerySetCell(q2,"name","carl");<br />   QuerySetCell(q2,"email","carl@r.org");<br /><br /> <br />   QueryAddRow(q2);<br />   QuerySetCell(q2,"id","3");<br />   QuerySetCell(q2,"name","ted");<br />   QuerySetCell(q2,"email","cop@pork.com");<br /><br />   q3 = QueryIntersect(q1,q2);<br /><br />   AssertTrue(q3.recordCount EQ q1.recordCount,"the wrong number of rows were in the intersection");<br />   AssertTrue(ListFindNoCase(q3.columnList,"id"), "id should be a column");<br />   AssertTrue(ListFindNoCase(q3.columnList,"name"), "name should be a column");<br />   AssertTrue(q3.id EQ 1, "first row id should have intersected");<br />   AssertTrue(q3.name EQ "", "first row name should not have intersected");<br />   AssertTrue(q3["id"][2] EQ "", "second id should NOT have intersected");<br />   AssertTrue(q3["name"][2] EQ "carl", "second name should have intersected");<br />   <br />  &lt;/cfscript&gt;<br /><br /> &lt;/cffunction&gt;<br /></pre><br /><br />I'll probably post another one later that does an intersection of all the rows in a single query as well.  (I updated the unit test to better reflect what this function does).</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Yeah the intersection is basically like matrice intersection.  I just happen to be using a Query structure to store my matrix.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Sorry to be such a noise maker.. But I figure I should explain my purpose for this function.<br /><br />Imagine you have a train that goes from station A to Station B then to Station C and then again to Station D  The train is responsible for logging its trips in some format and then transferring their log to me, the parent company, on a regular basis.  Now lets say the train forgot to log the trip between B and C and only logged the A-B and C-D.  Someone in the parent company knows the train (maybe via a verification phone call) that B-C happened, but the data isn&#39;t in the system.  So they want to quickly create a record for that trip.<br /><br />A lot of the information might be the same - but maybe not some things (for instance when the train got to D it might have had 1000 tons of coal and no iron ore but when it left A it had both coal and iron ore).<br /><br />I want to prepopulate the new trip creation form with everything that was consistent between leaving and and leaving C.. Then the user has to manually fill in the rest of the stuff that is &quot;different&quot; (and they might change some of the intersecting data as well).<br /><br />Hopefully this example (not an actual one) will clarify one place where such a function would be useful.</div>
</div>
<div class='comment'>
<div class='author'>Ben Nadel</div>
<div class='content'>
Hmmm, sorry, I think I misunderstood where you were intersecting - I think I am wrong.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
well email is a bad example since that column isn&#39;t returned.. but if I change Carls id in the second query the name carl should still come back even though the id shouldn&#39;t.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
hrm. the more I think about it the less I still think it will work - for instance in my example from the unit test the two queries being passed in in Row 1 nothing intersects - I think both solutions would handle that.<br /><br />However, in row 2 only the name and id fields should come back populated - the email field should be blank - I don&#39;t think the QoQ will handle that - at least I&#39;d be surprised if it did.<br /><br />We shall see shortly!</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Ok well I&#39;ll try it out and see what happens - my curiosity is piqued.</div>
</div>
<div class='comment'>
<div class='author'>Ben Nadel</div>
<div class='content'>
When you join two queries in a query of queries, it implies that it will be on a Row-by-row basis (hence you don&#39;t have to provide the row number).<br /><br />But, like I said, the two concepts are exactly similar - I&#39;m not recommending you switch - I was just trying to clarify what Rick was saying.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
I dunno - maybe I&#39;m just not getting what your saying but it seems to me that a query of the two queries will result in me getting back rows where q1.colX[row1] = q2.colX[row5] which I don&#39;t want.  I only want it to come back if q.colX[row1] = q2.colX[row1]<br /><br />Maybe in the query of queries you can also join on the rownumber metadata and I just don&#39;t know it but if not I am not sure what your saying will work.</div>
</div>
<div class='comment'>
<div class='author'>Ben Nadel</div>
<div class='content'>
I think what Rick was saying was that you could perform the same logic you are performing (comparing each column) inside of query of query:<br /><br />SELECT<br />*<br />FROM<br />q1, q1<br />WHERE<br />... loop to compare q1[col] = q2[col]<br /><br />Same exactly concept, just moving the comparison into the WHERE statement.<br /><br />However, within a query of queries, you *might* run into strange data type casting issues that you won&#39;t experience in your CFLoop solution.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Sorry Rick, I don&#39;t follow your logic?  There is no problem where data doesn&#39;t match up perfectly as far as I know - this intersection does what I expect (though, perhaps I don&#39;t explain that well).<br /><br />Please let me know what, in your suggestion, I&#39;m missing.  Thanks.</div>
</div>
<div class='comment'>
<div class='author'>Rick O</div>
<div class='content'>
Instead of doing the manual loop, why not use a Query of Queries?  This would also solve the problem where the column data doesn&#39;t match up perfectly.</div>
</div>
</div>
