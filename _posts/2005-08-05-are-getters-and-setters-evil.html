---
layout: post
title: "Are Getters and Setters Evil?"
date: 2005-08-05
comments: false
categories:
 - coldfusion
 - design patterns
---

<div class='post'>
I don't know if you have seen <a href="http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox_p.html">the articles by Allen Holub</a> or not but he thinks getters and setters are bad. Not always mind you, but most of the time. I am not going to repeat his arguments here but rather discuss my own thoughts about how those arguments apply to CF and the <a href="http://www.mail-archive.com/cfcdev@cfczone.org/">oft-discussed bean CFC</a>.<br /><br />Personally, I hate writing all the getters and setters.  That's why tools like <a href="http://rooibos.maestropublishing.com/">Peter Ferrel's bean generator</a> (and my lite-version bean-builder) exist. However, they don't really obviate the need for getters and setters, they just make writing them easier. Holub suggests that I shouldn't even need them.<br /><br />Supposedly, the get/set idiom was designed in Java to identify private properties of the class and were never meant to be called. Supposedly, the getters and setters reveal too much implementation detail because they are typed. What happens if the type changes in the future then everything that calls those getters and setters might have to be updated. This logic, to me, seems pretty dead on. Granted, CF isn't that strongly typed (for instance an int and a long are basically just CF strings that only contain numeric values so minor changes like that won't cause any problems in CF).<br /><br />Almost all of the instances where I see accessors methods are in the Beans that folks pass between their data access layer and their presentation or business layers. They are basically just glorified structures that have some validation built in. So, what is a developer to do when the data in that bean needs to be accessed by the data access object (DAO) for initialization or when it needs to be accessed by the view for display?<br /><br />Typically, with the <acronym title="Data Access Object">DAO</acronym> I don't need the setters to populate my newly instantiated Bean. I build a struct and then pass that struct into the init() method. The init method then takes care of populating all of the necessary private properties. It is the getting of the data that could be troublesome without "getter" methods.<br /><br />There are really only two types of getting that I can think of. 1. The requester needs the specific data value for some operation (writing to the db, or using it in a method) and 2. displaying the value (in the UI).<br /><br />Holub says that in a well designed system...<br /><blockquote>You may not ask for the information you need to do something. Rather, you must ask the collaborator who has the information to do the work. It's okay to pass to that collaborator information he needs to do the work, but keep this interaction to a minimum.</blockquote><br /><br />So, to accommodate this "rule" when you need the data value, say for saving to a DB, you should ask the bean to save (or to update, populate, or delete itself). At this point the bean will call the DAO and PASS the data to the create or update method. The whole bean shouldn't be passed to the DAO. The DAO should specify the data types it requires to be compatible with the data layer and the Bean should live up to that interface when passing the data to the DAO. This is a pattern that should be easy for any CF developer to work with and seems totally reasonable to me.<br /><br />Solving the issue of having the bean do something with it's data we now need to display it. Holub has a novel idea of giving the bean a "drawYourself()" method. Now, I don't know if that means he thinks it is OK to have a "drawX()" and "drawY()" method within an object; but I think that i what he means. So, if I am dealing with a user profile that has the properties "userID, userName, firstName, lastName, emailAddress, password" that there would be a draw() method for each property that needed to be presented in the <acronym title="User Interface">UI</acronym>.  This method would be responsible for creating the corresponding <acronym title="Hyper Text Markup Language">HTML</acronym> object and passing it back to the caller.<br /><br />At first glance this seems like both a crazy bad idea, and a good idea. If some property within my object changes drasticly to become more complex - then telling it to draw itself would only require me to update my code in one place, even if I were showing that property in many places throughout my UI (a very good thing). However, it also seems to plug some of my presentation layer into the business layer (or does it? The presentation layer takes this returned HTML object and puts it where it should be in the page hierarchy).<br /><br />While I like the idea of only updating my presentation in one place (well probably two thanks to <acronym title="Cascading Style Sheets">CSS</acronym> which I would probably be updating as well) the fact that I use CSS that makes me realize it isn't a simple "drawX()" method that is needed. In order for it to be flexible the draw method should take in a "class" or "style" argument that can be applied to that particular drawing instance. It also seems to me that the method should take in an option if it should draw an HTML control or not (say in a read only situation it is really just drawing the text representation?)<br /><br />Maintenance at this point would probably be easier. My final view page would look just like it always has - a dump of all the sub-views I have built - but the sub-views would be a bit different. In the following examples imagine each method takes to arguments "drawControl:BOOLEAN:DEFAULT=0 and class:STRING:DEFAULT=''"<br /><br /><pre name="code" class="coldfusion"><br />...<br />&lt;cfscript&gt;<br /> myobject.drawFirstName(1,"");<br /> myobject.drawLastName(1,"");<br /> myobject.drawUsername(1,"");<br /> myObject.drawEmailAddress(1,"");<br />&lt;/cfscript&gt;<br /><br />...<br /></pre><br /><br /><br />as opposed to<br /><pre name="code" class="coldfusion"><br />...<br />&lt;input type="text" name="firstName" value="#myObject.getFirstName()#" id="txtFirstName" /&gt;<br />&lt;input type="text" name="lastName" value="#myObject.getLastName()#" id="txtLastName" /&gt;<br />&lt;input type="text" name="userName" value="#myObject.getUsername()#" id="txtUsername" /&gt;<br />&lt;input type="text" name="emailAddress" value="#myObject.getEmailAddress()#" id="txtEmailAddress" /&gt;<br />...<br /></pre><br /><br />I admit this is a pretty strange way of looking at CF development in general particularly in regards to Beans. What do you think?</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Java Donkey</div>
<div class='content'>
Very interesting post.  I keep running into Holub's articles and it reminds me of when I first learned java.  You didn't see ANY getters or setters.  Just objects with properties and methods that did stuff with the properties.  I wrote about it in <A HREF="http://www.javadonkey.com/blog/are-getters-and-setters-evil/" REL="nofollow">Are Getters and Setters Evil?</A>.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
thanks for your comments!</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
There is no perfect answer for this. For the sake of votes, I vote for leaving the UI stuff out of the object aside from some simple display stuff that gives some concatenated string so the object can be uniquely identified in a list.<br /><br />However, the purpose of my business object is for "business." I'd rather not clutter up my object's interface with UI specific calls. Furthermore, on my current application my business objects serve a Web front end, Windows front end and a phone system front end. The UI developers can change anything they want about their displays and rarely ever need to rely on me, or get a new release of my business objects.<br /><br />I do expose an XML property to the web UI, but then when I saw the UI code using it I realized I might as well just exposed all the properties of the client. Client coders could load up the XML and pull out properties and act on the data etc. The XML was just another way to expose the data without getters for each property.<br /><br />No solution on my end that makes me happy in every case. But my favorite so far is to expose one Display property as I mentioned before. In 90% of the cases this is all a UI ever needs.<br /><br />For exampleâ€¦<br /><br />myPerson.Display <br /><br />Returns "Smith, Jones [123-45-6789]"</div>
</div>
<div class='comment'>
<div class='author'>deje162</div>
<div class='content'>
Or alternatively your drawYourself() methods can return unformatted xml which can be put thru an xslt tranformer to deliver whatever kind of front end you like.<BR/><BR/>The most important issue with getters is that they disrupt encapsulation. It is like declaring:<BR/>[code]<BR/>public private int x;<BR/>[/code]<BR/><BR/>thats just stupid. <BR/><BR/>The only argument FOR a getter is to intercept access and perform some mediation (NOBODY does this) and if you do you should be using an interface anyway.<BR/><BR/>Good points in ur entry.</div>
</div>
</div>
