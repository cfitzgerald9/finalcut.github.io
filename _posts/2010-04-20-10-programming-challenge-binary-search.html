---
layout: post
title: "10% Programming Challenge : Binary Search in ColdFusion"
date: 2010-04-20
comments: false
categories:
 - coldfusion
 - recursion
 - binary-search
 - iteration
 - binarysearch
 - computer-science
---

<div class='post'>
Yesterday I came across <a href="reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/">a programming article that basically stated that only 10% of programmers could successfully write a binary search function</a>.  I don't know how true the statement is but I can rarely turn down a challenge so I decided to give it a go.<br /><br />Before I show you my solution(s) here is the defintion of binary search provided in <a href="reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/">the linked article</a>:<br /><br /><blockquote>Binary search solves the problem [of searching within a pre-sorted array] by keeping track of a range within the array in which T [i.e. the sought value] must be if it is anywhere in the array.  Initially, the range is the entire array.  The range is shrunk by comparing its middle element to T and discarding half the range.  The process continues until T is discovered in the array, or until the range in which it must lie is known to be empty.  In an N-element table, the search uses roughly log(2) N comparisons.</blockquote><br /><br />If you are interested in attempting the challenge yourself don't keep reading until you've finished the challenge; then come back here and share your thoughts.<br /><br />Initially I decided to write my solution recursively because I tend to think that way more naturally and here was my solution:<br /><br /><pre name="code" class="coldfusion"><br />&lt;cffunction name="binarySearchRecursive" returntype="boolean" output="false"&gt;<br /> &lt;cfargument name="ary" type="array" required="true" /&gt;<br /> &lt;cfargument name="val" type="string" required="true" /&gt;<br /><br /> &lt;cfset var l = structNew() /&gt;<br /><br /> &lt;cfif ArrayLen(arguments.ary)&gt;<br />  &lt;cfif ArrayLen(arguments.ary) GT 1&gt;<br />   &lt;cfif ArrayLen(arguments.ary) EQ 2&gt;<br />    &lt;cfreturn VAL((arguments.ary[1] EQ arguments.val OR arguments.ary[2] EQ arguments.val))&gt;<br />   &lt;cfelse&gt;<br />    &lt;cfset l.pos = Round(ArrayLen(arguments.ary)/2) /&gt;<br />    <br />    &lt;cfif arguments.ary[l.pos] EQ arguments.val &gt;<br />     &lt;cfreturn 1 /&gt;<br />    &lt;cfelseif arguments.ary[l.pos] GT arguments.val&gt;<br />     &lt;cfset arguments.ary = ArraySplit(arguments.ary, 1, l.pos) /&gt;<br />    &lt;cfelse&gt;<br />     &lt;cfset arguments.ary = ArraySplit(arguments.ary, l.pos, ArrayLen(arguments.ary)) /&gt;<br />    &lt;/cfif&gt;<br /><br />    &lt;cfreturn binarySearchRecursive(arguments.ary, arguments.val) /&gt;<br />   &lt;/cfif&gt;<br /><br />  &lt;cfelse&gt;<br />   &lt;cfif (arguments.ary[1] EQ arguments.val)&gt;<br />    &lt;cfreturn 1 /&gt;<br />   &lt;cfelse&gt;<br />    &lt;cfreturn 0/&gt;<br />   &lt;/cfif&gt;<br />  &lt;/cfif&gt;<br /> &lt;cfelse&gt;<br />  &lt;cfreturn 0 /&gt;<br /> &lt;/cfif&gt;<br />&lt;/cffunction&gt;<br /><br />&lt;cffunction name="ArraySplit" returntype="array"&gt;<br /> &lt;cfargument name="ary" type="array"&gt;<br /> &lt;cfargument name="sp" type="numeric"&gt;<br /> &lt;cfargument name="ep" type="numeric"&gt;<br /><br /> &lt;cfset var l = structNew() /&gt;<br /> &lt;cfif arguments.ep LT arguments.sp&gt;<br />  &lt;cfthrow message="End Point must be greater than or equal to the starting point" /&gt;<br /> &lt;/cfif&gt;<br /> &lt;cfif arguments.ep GT ArrayLen(arguments.ary)&gt;\<br />  &lt;cfthrow message="End point can not be greater than the size of the array to split" /&gt;<br /> &lt;/cfif&gt;<br /> &lt;cfif arguments.sp GT arguments.sp&gt;<br />  &lt;cfthrow message="Start Point must be less than or equal to the size of the array to split" /&gt;<br /> &lt;/cfif&gt;<br /><br /> &lt;cfset l.a = ArrayNew(1) /&gt;<br /> &lt;cfloop from="#arguments.sp#" to="#arguments.ep#" index="l.i"&gt;<br />  &lt;cfset ArrayAppend(l.a, arguments.ary[l.i]) /&gt;<br /> &lt;/cfloop&gt;<br /><br /><br /> &lt;cfreturn l.a /&gt;<br />&lt;/cffunction&gt;<br /></pre><br /><br />As you can see I also had to write a function to split an array.  In my initial effort I did not take into consideration an empty array being passed in but this final example I'm showing fixes that bug.  Because of that bug I guess I fell outside the 10% of people who do this successfully on their very first try though I saw the problem in my code before looking at any other examples or reading any of the comments in the aforementioned post.<br /><br />I also thought that I should challenge myself and try to write the function in an iterative fashion that wouldn't have the dependency on the ArraySplit function.  The recursive solution took me about 5 minutes to write; the iterative one took me closer to 20; it's just not how I think so I had to give some deep thought to my looping conditional.  Anyway, here it is for comparison sake:<br /><br /><pre name="code" class="coldfusion"><br />&lt;cffunction name="binarySearchIterative" returntype="boolean" output="false"&gt;<br /> &lt;cfargument name="ary" type="array" required="true" /&gt;<br /> &lt;cfargument name="val" type="string" required="true" /&gt;<br /> &lt;cfset var l = structNew() /&gt;<br /> <br /> &lt;cfif ArrayLen(arguments.ary) EQ 0&gt;<br />  &lt;cfreturn 0 /&gt;<br /> &lt;cfelseif ArrayLen(arguments.ary) EQ 1&gt;<br />  &lt;cfreturn arguments.ary[1] EQ arguments.val /&gt;<br /> &lt;cfelse&gt;<br />  &lt;cfset l.min = 1&gt;<br />  &lt;cfset l.max = ArrayLen(arguments.ary) /&gt;<br />  &lt;cfloop condition="l.max GTE l.min"&gt;<br />   &lt;cfset l.mid = l.min + Round((l.max-l.min)/2) /&gt;<br />   &lt;cfset l.value = arguments.ary[l.mid] /&gt;<br />   &lt;cfif l.value EQ arguments.val&gt;<br />    &lt;cfreturn 1 /&gt;<br />   &lt;cfelseif l.value GT arguments.val&gt;<br />    &lt;cfset l.max = l.mid - 1 /&gt;<br />   &lt;cfelse&gt;<br />    &lt;cfset l.min = l.mid + 1 /&gt;<br />   &lt;/cfif&gt;<br />  &lt;/cfloop&gt;<br />  &lt;cfreturn 0 /&gt;<br /> &lt;/cfif&gt;<br />&lt;/cffunction&gt;<br /></pre><br /><br />To be honest it is a heck of a lot cleaner and I like it a lot more.  It also turns out to be a heck of a lot faster which we shall see in a second.  Here is my basic performance test harness:<br /><br /><pre name="code" class="coldfusion"><br />&lt;cfset myAry = ArrayNew(1) /&gt;<br />&lt;cfloop from="1" to="9000" index="i"&gt;<br /> &lt;cfset ArrayAppend(myAry,i) /&gt;<br />&lt;/cfloop&gt;<br /><br /><br />&lt;cffunction name="testBS" output="true"&gt;<br /> &lt;cfargument name="ary" /&gt;<br /> &lt;cfargument name="func" /&gt;<br /> &lt;cfargument name="ftype" /&gt;<br /><br /><br />&lt;cfoutput&gt;&lt;h2&gt;#fType# Binary Search&lt;/h2&gt;&lt;/cfoutput&gt;<br />&lt;cftimer<br /> label="#ftype# total time: "<br /> type="outline"&gt;<br />&lt;cfoutput&gt;&lt;pre&gt;<br /> #arguments.func(ary, 8)#<br /> #arguments.func(ary, 13)#<br /> #arguments.func(ary,0)#<br /> #arguments.func(ary,100)#<br /> #arguments.func(ary,190)#<br /> #arguments.func(ary,504)#<br /> #arguments.func(ary,700)#<br /> #arguments.func(ary,893)#<br /> #arguments.func(ary,9876)#<br /> #arguments.func(ary,5001)#<br /> #arguments.func(ary,2091)#<br /> #arguments.func(ary,9010)#<br /> #arguments.func(ary,9999)#<br /> #arguments.func(ary,109876)#<br /> #arguments.func(ary,-2321)#<br />&lt;/pre&gt;&lt;/cfoutput&gt;<br />&lt;/cftimer&gt;<br />&lt;/cffunction&gt;<br /><br />&lt;cfset testBS(myAry,binarySearchIterative,"Iterative") /&gt;<br />&lt;cfset testBS(myAry,binarySearchRecursive,"Recursive") /&gt;<br /></pre><br /><br />On average the iterative tests run in about 15-20ms while the recursive option runs in about 650-700ms.  There are some obvious reasons for this the first being my ArraySplit function which could probably be written a lot better.  However, I also remember that, inherently, <a href="http://www.informit.com/articles/article.aspx?p=1390173&seqNum=3">recursion is slow</a>.<br /><br />Finally, you may note that I get my "mid" point a little strangely using the (min + ((max-min)/2)) process.  I do this because I actually remembered reading <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">this article</a>.  That article is also linked to via the challenge page.  What's funny is that I remembered the nugget about min + (max-min)/2 to get the mid point but I didn't remember the context which just happens to be a Binary Search function post.  I had completely forgotten WHY I did it that way but I'm glad the basic rule at least stuck into my brain from whenever I had read that post previously.  To be truthful I doubt any code I ever write in CF will need that type of protection against overflows - I've never worked with an Array anywhere near 2<sup>30</sup> elements long so I would undoubtedly be safe using just l.mid = (l.min+l.max)/2</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Rick,<br /><br />Sorry I just saw your comment about teaching the web design degree.  I agree that nobody can learn everything in 4 years!  Heck, even if you tried so much new stuff could come out during that 4 years it would be just as if you are starting over again.<br /><br />I was asked to teach a course in advanced web development at a community college once.  It was not an easy task in part because I expected the students to know more than they did by that point and in part because I had so much material to cover in one semester.<br /><br />The students did not appreciate my approach but I didn&#39;t really feel like I had many options - they were woefully unprepared for their capstone course.<br /><br />I was supposed to be teaching databsae driven webdevelopment but they didn&#39;t even have a good grasp of HTML and yet I was supposed to teach them SQL and asp.net?  I was not asked to come back and teach again.<br /><br />I spent most of the semester teaching them HTML and and ColdFusion because I figured they would be able to learn CF faster due to its tag based syntax.</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
I think I would only use this as a type of interviewee if it was applicable to their job.<br /><br />If a candidate admitted they weren&#39;t familiar with the term &quot;binary search&quot; I&#39;d be a little surprised but if they could take the definition and create something that basically worked I&#39;d be satisfied.  In fact if someone didn&#39;t know what a binary search was and just try to BS me I&#39;d be pretty disappointed.  Asking a question for additional information is a plus (so long as you can actually do the work once you have the info).<br /><br />Personally, in my little corner of the geek circle I don&#39;t care if anyone ever asked me what &quot;Binary Search&quot; was.  In fact, in general, I don&#39;t like talking about what I do for a living with people who don&#39;t do similar things.  Most of the crap I do isn&#39;t very easily explainable beyond big general concepts.  I doubt that is particularly unique to my career field either (considering, in order to build custom software I&#39;m constantly having to learn how other people do their job and how difficult it can be for them to really explain what they do).</div>
</div>
<div class='comment'>
<div class='author'>Jake Munson</div>
<div class='content'>
I&#39;d guess that a big portion of the other 90% don&#39;t even know what &quot;binary search&quot; means.  I&#39;ll admit that I didn&#39;t until I read your pasted definition.  After reading it, I said to myself, &quot;Oh yeah, I know how to do that!&quot;  <br /><br />I think this kind of thing is common in geek circles.  We like to use acronyms and big words, and we are partly hoping people will ask us, &quot;Wait, what does binary search mean?&quot; because then we feel smarter.  And to make matters worse, there are often multiple terms that mean the same thing (when you travel between different programming languages, for example.)<br /><br />I can see this being an interview question, &quot;Demonstrate with pseudo code that you can write a binary search.&quot;  And the poor interviewee is sitting there wracking their brain for that long lost definition that they forgot 10 years ago.  And of course, if you ask what the term means, you don&#39;t get the job (because they think you obviously aren&#39;t good enough if you don&#39;t know what binary search means).  If you don&#39;t demonstrate it correctly, you don&#39;t get the job.  Double edged sword.  Meanwhile, this interviewee may well be the best candidate among the lot, if given a chance.</div>
</div>
<div class='comment'>
<div class='author'>Rick O</div>
<div class='content'>
The degree that I teach for is a BS in &quot;Web Design and Development&quot;.  It&#39;s <i>not</i> a CS degree.  We don&#39;t explicitly teach how to code algorithms like sorts and searches.  Instead, our students get HTML, CSS, JavaScript, jQuery, Flash, Flex, PHP, SQL, and ColdFusion -- and a bunch of other non-programming web technology courses, such as rich media streaming technologies.<br /><br />Of course, we&#39;re always asked why the degree isn&#39;t a CS degree, and why we don&#39;t teach the hard stuff.  But flip the question around: why don&#39;t CS degrees go into even half of what we do?  There&#39;s just not enough time to cover both in a 4-year degree.<br /><br />You could argue that the CS student would have a solid enough base to be able to pick up on any of those technologies ... but you could also argue that our students are familiar with a breadth of technologies, and those technologies don&#39;t change all that fast, so they&#39;ll probably transition just as easily into new technologies.<br /><br />The reality is that there&#39;s room in the world for both types of degrees and both types of web devs.  Some of our students are simply amazing designers and developers, some of them even have a CS background (or future), and many of them will be content somewhere in the middle of the two.<br /><br />(I, too, come from a hard CS background.  I&#39;ll admit that I occasionally have to stop and remind myself that I&#39;m <i>not</i> teaching a CS degree.  When all you have is a hammer... )</div>
</div>
<div class='comment'>
<div class='author'>Bill</div>
<div class='content'>
Good comment Rick.  I&#39;m in the CS camp personally; but I enjoy both the creative and the algorithmic side of things.  I just wish had some graphic design skills so that, on occasion, I could put a pretty face on something I was building.<br /><br />I work in a pretty small shop (about 10-15 developers) and we do almost no public facing web work but the majority of the web stuff we do is in CF.<br /><br />Our path into CF development was pretty funny.  A marketing guy who used to work here misunderstood someone and thought they were talking about net objects fusion back when CF was still at 3.5 or 4.  He told the prospective customer we had plenty of experience with CF and so that day we started learning CF so that if the customer called back we could actually build what they wanted; they did, we did, and the rest (as they say) is history.</div>
</div>
<div class='comment'>
<div class='author'>Rick O</div>
<div class='content'>
If you look back at the history of web development, it&#39;s followed a twisty path.<br /><br />In the beginning, early to late 90s, pretty much anyone doing web work had a CompSci degree.  Everything was new and difficult and had to be coded by hand, so if you didn&#39;t have a CS degree you were behind a very large 8-ball.<br /><br />Then, at the end of the decade, something weird happened: the non-CS-folks (read: creatives) got really fed up with being out of the loop.  They pushed back hard, and we got things like Flash and ColdFusion and WYSIWYG editors -- a whole slew of technologies that didn&#39;t require a CS degree to use.  It took those technologies a number of years to really take hold in the market, but as they grew they shifted from making things easier for CS-minded people, to making things easier for the entry-level web dev.<br /><br />By the mid 2000s we were beginning to see a new class of web dev: people that had <b>only</b> ever used those &quot;soft&quot; web dev technologies.  These were people without a CS degree.  They weren&#39;t raised on algorithms and data structures and memory/performance optimization.  These folks began to dominate the market for one simple reason: they didn&#39;t try to overengineer their deliverables, as they hadn&#39;t been pumped full of waterfall methodology and all that rot.<br /><br />ColdFusion developers are a great example of this entire lifecycle.<br /><br />But now it&#39;s beginning to come full circle: as we begin to have to face questions of scale, it&#39;s becoming apparent to the new guys that they aren&#39;t quite up to the task of making the really big stuff even bigger.  There&#39;s beginning to be a real distinction between web development, web design, and web programming.  I think this is great -- it makes it easier for employers and employees to figure out what they want and what they want to be.</div>
</div>
</div>
