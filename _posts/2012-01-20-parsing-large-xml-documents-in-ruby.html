---
layout: post
title: "Parsing Large XML Documents in Ruby"
date: 2012-01-20
comments: false
categories:
 - ruby
 - nokogiri::xml::reader
 - nokogiri::xml::node
 - nokogiri
 - xml
 - nokogiri::xml::nodeset
---

<div class='post'>
Today I was given a fairly large XML file (roughly 32 Mb) that I needed to parse in order to see if there was a match between a concatenation between two node values and the contents of a separate file that had comma separated values in it. &nbsp;Always looking for an excuse to use a different language than I normally do I decided to attack this in Ruby because I remember it being particularly good at handling File IO.<br /><br />I'm going to present two solutions to this problem here. &nbsp;I'm sure they can both be improved. &nbsp;However, the second solution was the one I settled on because it is substantially more performant.<br /><br /><span style="font-size: large;">Example 1 - Using SimpleXML</span><br />Look, I don't know Ruby well at all so when I saw a library called SimpleXML I thought - "sweet that's right up my alley!" &nbsp;It really was easy to use but, as you'll see, it wasn't the right tool for this particular job.<br /><br /><br /><pre class="ruby" name="code">require 'rubygems'<br /> require 'xmlsimple'<br /><br /> duplicates = Array.new()<br /> enrollments = Array.new()<br /><br /><br /> # read in the xml of enrollments<br /> puts "reading in enrollment file; this could take a while."<br /> data = XmlSimple.xml_in('students.xml')<br /><br /> puts "enrollment file loaded; now to parse it!"<br /> cnt = 0<br /> data['membership'].each do |course|<br />  courseId = course["sourcedid"][0]["id"][0].strip<br />  course["member"].each do |student|<br />   studentId = student["sourcedid"][0]["id"][0].strip<br />   enrollmentId = studentId &lt;&lt; "," &lt;&lt; courseId<br />   enrollments.push(enrollmentId)<br />  end<br />  cnt++<br />  if cnt &gt; 9 then<br />   p "."<br />   cnt = 0<br />  end<br /> end<br /><br /><br /> #read in the comma delimited list..<br /> puts "reading in the drop file"<br /> drops = File.readlines("term_drops.lis");<br /> drops.delete_at(drops.length-1)<br /><br /><br /> drops = drops.collect{|x| x.strip}<br /><br /> puts "comparing..."<br /><br /> duplicates = enrollments &amp; drops<br /><br /> if duplicates.size &gt; 0 then<br />  puts "found the following duplicate enrollments"<br />  puts duplicates<br /> else<br />  puts "YES! no duplicates found"<br /> end<br /></pre><br />By far the slowest part of this process was the line data = XmlSimple.xml_in('students.xml') - in fact with my large XML file I got bored and gave up waiting for it to load.  What I needed was a parser that would pull in one node of the document at a time.<br /><br /><span style="font-size: large;">Nokogiri</span><br /><br />It turns out there are a few solutions but I settled on Nokogiri and I'm glad I did. Honestly, the documentation is a little confusing but the library itself works great.  <br /><pre class="ruby" name="code">require 'rubygems'<br /> require 'nokogiri'<br /><br /> duplicates = Array.new()<br /> enrollments = Array.new()<br /><br /><br /> puts "reading in drops file"<br /> drops = File.readlines("term_drops.lis");<br /> drops.delete_at(drops.length-1)<br /> drops = drops.collect{|x| x.strip}<br /><br /><br /> puts "reading in enrollment file; this could take a while."<br /> data = Nokogiri::XML::Reader(File.open("students.xml"))<br /><br /> data.each do |node|<br />  if(node.name == "membership" &amp;&amp; node.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT)<br />   doc = Nokogiri::XML(node.outer_xml)<br />   classId = doc.xpath("//sourcedid/id")[0].inner_text.strip<br />   studentId = doc.xpath("//member/sourcedid/id")[0].inner_text.strip<br />   enrollmentId = studentId &lt;&lt; "," &lt;&lt; classId<br /><br />   if drops.include?(enrollmentId) then<br />    puts  enrollmentId<br />   end<br />  end<br /> end<br /></pre><br />As you can see both scripts are pretty short - ruby really is nice for this kind of stuff. &nbsp;I also do a few weird things in both concerning the way I pull in my comma delimited flat file (I drop off the last line for instance but I don't really have to).<br /><br />Their were a couple little gotcha's I ran into using Nokogiri. &nbsp;First is that when I do the data.each do |node| block it literally will iterate over every node in the document down to the most distant child. &nbsp;Thus I needed to filter things out by using the node.name check. &nbsp;Secondly, when it iterates it actually deals with every node twice; once on entering the node and once on exiting it. &nbsp;That is why I am checking for the node_type as well as the node.name.<br /><br />Also, and this was just stupidity on my part, in order for me to do the xpath query on the node (after creating a small xml document using Nokogiri) I had to use outer_xml and not inner_xml. &nbsp;Using inner_xml worked ok when I was just searching for the classId because when I created the document using inner_xml it actually ignored all sibling nodes to the sourcedid node. <br /><br />I also don't really know xpath all that well thus there is probably a better way for me to make sure I'm only getting the first sourcedid when I ask for classId instead of ALL sourcedid values in the document when I fire of the xpath query. &nbsp;I'm not really sure; if there is feel free to let me know in the comments.<br /><br />Overall this code is pretty rough and specialized for this one off task I was asked to do but hopefully the Nokogiri code will help others as they parse an xml document while looking for values that might be spread out over various nodes.<br /><br /><br /></div>
