---
layout: post
title: "Coldspring - Config Bean Inheiritance"
date: 2008-10-18
comments: false
categories:
 - coldfusion
 - oop
 - coldspring
---

<div class='post'>
In one of my apps a large chunk of the basic config data is the same but 2 fields are different depending on which client you are logged in as: the datasource and the clientSchema name.  However, each client still needs the rest of that config data; so I rolled a means of supporting inheritance in my coldspring bean.  Inheritance of ColdSpring defined properties as opposed to inheritance of functionality specifically.<br /><br />Every configService bean I have has to extend this:<br /><pre name="code" class="xml"><br /> &lt;bean id="baseConfigService" class="LB2.config.beans.baseConfigService" singleton="true"&gt;<br />  &lt;property name="properties"&gt;<br />   &lt;map&gt;<br />    &lt;entry key="importDSN"&gt;&lt;value&gt;SpecialAccessDBDataSourcePlaceHolder&lt;/value&gt;&lt;/entry&gt;<br />    <br />    &lt;entry key="rootPath"&gt;&lt;value&gt;C:\dev\websites\WEBSITE\PATH\&lt;/value&gt;&lt;/entry&gt;<br />    &lt;entry key="relRoot"&gt;&lt;value&gt;/MySiteRoot/&lt;/value&gt;&lt;/entry&gt;<br />    <br />    &lt;entry key="siteEmailAddress"&gt;&lt;value&gt;AdminEmailAddress&lt;/value&gt;&lt;/entry&gt;<br />    &lt;entry key="commonSchema"&gt;&lt;value&gt;SHARED_SCHEMA_NAME&lt;/value&gt;&lt;/entry&gt;<br />   &lt;/map&gt;<br />  &lt;/property&gt;<br /> &lt;/bean&gt;<br /></pre><br /><br />Normally I would have to have that exact same stuff pasted into each clients config bean definition which, frankly, sucked because the paths and datasource names change depending on how the customer wants them all setup so then he had to make a bunch of duplicate edits.  Not a good plan at all.  Now a client specific configService bean looks like this:<br /><br /><pre name="code" class="xml"><br /> &lt;bean id="clientXConfigService" class="LB2.config.beans.configService" singleton="false"&gt;<br /><br />  &lt;property name="properties"&gt;<br />   &lt;map&gt;<br />    &lt;entry key="dsn"&gt;&lt;value&gt;CLIENT_DATASOURCE&lt;/value&gt;&lt;/entry&gt;<br />    &lt;entry key="clientSchema"&gt;&lt;value&gt;CLIENT_SPECIFIC_SCHEMA&lt;/value&gt;&lt;/entry&gt;<br />   &lt;/map&gt;<br />  &lt;/property&gt;<br /><br />  &lt;property name="baseConfigService"&gt;<br />   &lt;ref bean="baseConfigService"/&gt;       <br />  &lt;/property&gt;<br /> &lt;/bean&gt;<br /></pre><br /><br />Now, this might seem kind of obvious so far but really, what I want to be able to do is call my client level config service, and ask for a property that might exist in either the base service or the client service and have it return it without any of my code caring at which level the property is defined.  This is taken care of through my baseConfigService.cfc and the configService.cfc.<br /><br /><h3>baseConfigService.cfc</h3><br /><pre name="code" class="xml"><br />&lt;!--- <br />---&gt;<br /><br />&lt;cfcomponent name="baseConfigService"<br />    hint="Config Service API."&gt;<br /><br /> &lt;cffunction name="init" access="public" returntype="LB2.config.beans.baseConfigService" output="false"<br />    hint="Constructor. I create a new ConfigService"&gt;<br />  &lt;cfset variables.properties = structnew()/&gt;<br />  &lt;cfreturn this/&gt;<br /> &lt;/cffunction&gt;<br /><br /> &lt;cffunction name="setProperties" access="public" returntype="void" output="false"<br />    hint="I overwrite all propertie in the configuration service"&gt;<br />  &lt;cfargument name="properties" type="struct" required="true" /&gt;<br />  <br />  &lt;cfset variables.properties = arguments.properties  /&gt;<br /><br /> &lt;/cffunction&gt;<br /><br /> &lt;cffunction name="setProperty" access="public" returntype="void" output="false"<br />    hint="I set a property in the configuration service"&gt;<br />  &lt;cfargument name="PropertyName" type="string" required="true" /&gt;<br />  &lt;cfargument name="PropertyValue" type="any" required="true" /&gt;  <br />  <br />  &lt;cfset variables.properties[arguments.propertyName] = arguments.propertyValue /&gt;<br />  <br /> &lt;/cffunction&gt;<br /><br /> &lt;cffunction name="getProperty" access="public" returntype="any" output="false"<br />    hint="I get a property from the configuration service"&gt;<br />  &lt;cfargument name="PropertyName" type="string" required="true" /&gt;<br /><br />  &lt;cfif structKeyExists(variables.properties,arguments.propertyName)&gt;<br />   &lt;cfreturn variables.properties[arguments.propertyName]/&gt;<br />  &lt;cfelse&gt;<br />   &lt;cfthrow type="ConfigSerivce.PropertyNotFoundException" message="Property: #arguments.propertyName# is not known to the config service and thus cannot be retrieved." /&gt;<br />  &lt;/cfif&gt;<br /><br /> &lt;/cffunction&gt;<br /> <br /><br /> &lt;cffunction name="removeProperty" access="public" returntype="any" output="false"<br />    hint="I remove a property from the configuration service"&gt;<br />  &lt;cfargument name="PropertyName" type="string" required="true" /&gt;<br /> <br />  &lt;cfif structKeyExists(variables.properties,arguments.propertyName)&gt;<br />   &lt;cfset structDelete(variables.properties,arguments.propertyName)/&gt;<br />  &lt;cfelse&gt;<br />   &lt;cfthrow type="ConfigSerivce.PropertyNotFoundException" message="Property: #arguments.propertyName# is not known to the config service and thus cannot be removed." /&gt;<br />  &lt;/cfif&gt;<br />  <br /> &lt;/cffunction&gt;<br /> <br /><br />&lt;/cfcomponent&gt;<br /></pre><br /><br />My configService cfc actually has a child object in it of type baseConfigService while also extending the baseConfigService at the same time.<br /><br /><h3>configService.cfc</h3><br /><pre name="code" class="xml"><br />&lt;cfcomponent name="ConfigService"<br />    hint="Config Service API."  extends="baseConfigService"&gt;<br /><br /> &lt;cffunction name="init" access="public" returntype="LB2.config.beans.ConfigService" output="false"<br />    hint="Constructor. I create a new ConfigService"&gt;<br />  &lt;cfset variables.properties = structnew()/&gt;<br />  &lt;cfset variables.baseproperties = "" /&gt;<br />  &lt;cfreturn this/&gt;<br /> &lt;/cffunction&gt;<br /><br /> &lt;cffunction name="getProperty" access="public" returntype="any" output="false"<br />    hint="I get a property from the configuration service"&gt;<br />  &lt;cfargument name="PropertyName" type="string" required="true" /&gt;<br /><br />  &lt;cfset var val = "" /&gt;<br /><br /><br />  &lt;cfif structKeyExists(variables.properties,arguments.propertyName)&gt;<br />   &lt;cfset val = trim(variables.properties[arguments.propertyName])/&gt;<br />  &lt;cfelse&gt;<br />   &lt;cfset val = trim(getBaseProperty(arguments.propertyName)) /&gt;<br />   &lt;cfset setProperty(arguments.propertyName, val) /&gt;<br />  &lt;/cfif&gt;<br /><br />  &lt;cfif NOT LEN(val)&gt;<br />   &lt;cfthrow type="ConfigSerivce.PropertyNotFoundException" message="Property: #arguments.propertyName# is not known to the config service and thus cannot be retrieved." /&gt;<br />  &lt;/cfif&gt;<br />  <br />  &lt;cfreturn val /&gt;<br /> &lt;/cffunction&gt;<br /> <br /> &lt;cffunction name="getBaseProperty" access="private" returntype="any" output="true"<br />   hint="I try to get a property from the base setting object if it exists"&gt;<br />  &lt;cfargument name="PropertyName" type="string" required="true" /&gt;<br /><br />   &lt;cfset var val = "" /&gt;<br /><br /><br />    &lt;cfif isObject(variables.baseproperties)&gt;<br />    &lt;cftry&gt;<br />     &lt;cfset val = variables.baseproperties.getProperty(arguments.PropertyName) /&gt;<br />     &lt;cfcatch&gt;<br />      &lt;!--- do nothing if the base fails ---&gt;<br />     &lt;/cfcatch&gt;<br />    &lt;/cftry&gt;<br />    &lt;/cfif&gt;<br /><br />   &lt;cfreturn val /&gt;<br /><br /> &lt;/cffunction&gt;<br /><br /><br /> &lt;cffunction name="setBaseConfigService" access="public" returntype="void" output="false"&gt;<br />  &lt;cfargument name="settings" type="any"&gt;<br />  <br />  &lt;cfset  variables.baseproperties = arguments.settings /&gt;<br /> &lt;/cffunction&gt;<br /><br />&lt;/cfcomponent&gt;<br /></pre><br /><br />Now you can see, my clientConfig service tries to find the property locally and if that fails then it tries to find it in the baseConfigService.  If it finds it in the baseConfigService it caches it locally so it doesn't have to dig down later.  If it can't find the property at either level then an exception is thrown.<br /><br /><h4>Incorporating Parent Beans</h4><br />When ColdSpring 1.2 first came out I had hoped that I could simplify this setup by using the <a href="http://www.coldspringframework.org/coldspring/examples/quickstart/index.cfm?page=parentbeans">parent attribute</a> and then I could just have the main properties defined in one bean and have the secondary properties defined in each client bean.  This basically ends up defining the properties node twice within one bean.  It turns out, unsurprisingly, that you can't really do this.  What did suprise me was that ColdSpring doesn't throw an exception it just ignores the second properties node (that which is defined in the baseConfigService bean definition).<br /><br />You could pretty easily refactor what I have done though to support the idea of the parent bean but I'm not sure anything would be gained from it; in fact I think it would probably just cause me to have a less readable coldspring configuration.<br /><br />Sadly, I can't incorporate the Parent Bean to help improve this method.  Both my baseConfigService and my configService define a property element named properties.  By defining the parentBean the properties element in the baseConfigService is just ignored.</div>
